<h1><code ng:non-bindable="">Grid</code>
<span class="hint">(class in module <code ng:non-bindable="">ui.grid</code>
)</span>
</h1>
<div><h2 id="Description">Description</h2>
<div class="description"><p>Grid is the main viewModel.  Any properties or methods needed to maintain state are defined in
this prototype.  One instance of Grid is created per Grid directive instance.</p></div>
<h2 id="Usage">Usage</h2>
<div class="usage"><pre class="prettyprint linenums">Grid(options);</pre>
<h3 id="Parameters">Parameters</h3>
<ul class="parameters"><li><code ng:non-bindable="">options – {object} – </code>
<p>Object map of options to pass into the grid. An 'id' property is expected.</p></li>
</ul>
</div>
<div class="member method"><h2 id="Methods">Methods</h2>
<ul class="methods"><li><h3 id="addRowHeaderColumn">addRowHeaderColumn(column)</h3>
<div class="addrowheadercolumn"><p>adds a row header column to the grid</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">column – {object} – </code>
<p>def</p></li>
</ul>
</div>
</li>
<li><h3 id="assignTypes">assignTypes()</h3>
<div class="assigntypes"><p>uses the first row of data to assign colDef.type for any types not defined.</p></div>
</li>
<li><h3 id="buildColumnDefsFromData">buildColumnDefsFromData(rowBuilder)</h3>
<div class="buildcolumndefsfromdata"><p>Populates columnDefs from the provided data</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rowBuilder – {function(colDef, col, gridOptions)} – </code>
<p>function to be called</p></li>
</ul>
</div>
</li>
<li><h3 id="buildColumns">buildColumns(options)</h3>
<div class="buildcolumns"><p>creates GridColumn objects from the columnDefinition.  Calls each registered
columnBuilder to further process the column</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">options – {object} – </code>
<p>An object contains options to use when building columns</p>

<ul>
<li><strong>orderByColumnDefs</strong>: defaults to <strong>false</strong>. When true, <code>buildColumns</code> will reorder existing columns according to the order within the column definitions.</li>
</ul></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{Promise}</code>
– <p>a promise to load any needed column resources</p></div>
</div>
</li>
<li><h3 id="buildStyles">buildStyles()</h3>
<div class="buildstyles"><p>calls each styleComputation function</p></div>
</li>
<li><h3 id="callDataChangeCallbacks">callDataChangeCallbacks(type)</h3>
<div class="calldatachangecallbacks"><p>Calls the callbacks based on the type of data change that
has occurred. Always calls the ALL callbacks, calls the ROW, EDIT, COLUMN and OPTIONS callbacks if the 
event type is matching, or if the type is ALL.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">type – {number} – </code>
<p>the type of event that occurred - one of the 
uiGridConstants.dataChange values (ALL, ROW, EDIT, COLUMN, OPTIONS)</p></li>
</ul>
</div>
</li>
<li><h3 id="columnRefreshCallback">columnRefreshCallback(name)</h3>
<div class="columnrefreshcallback"><p>refreshes the grid when a column refresh
is notified, which triggers handling of the visible flag. 
This is called on uiGridConstants.dataChange.COLUMN, and is 
registered as a dataChangeCallback in grid.js</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">name – {string} – </code>
<p>column name</p></li>
</ul>
</div>
</li>
<li><h3 id="createLeftContainer">createLeftContainer()</h3>
<div class="createleftcontainer"><p>creates the left render container if it doesn't already exist</p></div>
</li>
<li><h3 id="createRightContainer">createRightContainer()</h3>
<div class="createrightcontainer"><p>creates the right render container if it doesn't already exist</p></div>
</li>
<li><h3 id="flagScrollingHorizontally">flagScrollingHorizontally()</h3>
<div class="flagscrollinghorizontally"><p>sets isScrollingHorizontally to true and sets it to false in a debounced function</p></div>
</li>
<li><h3 id="flagScrollingVertically">flagScrollingVertically()</h3>
<div class="flagscrollingvertically"><p>sets isScrollingVertically to true and sets it to false in a debounced function</p></div>
</li>
<li><h3 id="getCellValue">getCellValue(row, col)</h3>
<div class="getcellvalue"><p>Gets the value of a cell for a particular row and column</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">row – {GridRow} – </code>
<p>Row to access</p></li>
<li><code ng:non-bindable="">col – {GridColumn} – </code>
<p>Column to access</p></li>
</ul>
</div>
</li>
<li><h3 id="getColDef">getColDef(name)</h3>
<div class="getcoldef"><p>returns a grid colDef for the column name</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">name – {string} – </code>
<p>column.field</p></li>
</ul>
</div>
</li>
<li><h3 id="getColumn">getColumn(name)</h3>
<div class="getcolumn"><p>returns a grid column for the column name</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">name – {string} – </code>
<p>column name</p></li>
</ul>
</div>
</li>
<li><h3 id="getColumnSorting">getColumnSorting()</h3>
<div class="getcolumnsorting"><p>Return the columns that the grid is currently being sorted by</p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{Array[GridColumn]}</code>
– <p>An array of GridColumn objects</p></div>
</div>
</li>
<li><h3 id="getGridQualifiedColField">getGridQualifiedColField(col)</h3>
<div class="getgridqualifiedcolfield"><p>Returns the $parse-able accessor for a column within its $scope</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">col – {GridColumn} – </code>
<p>col object</p></li>
</ul>
</div>
</li>
<li><h3 id="getRow">getRow(rowEntity, rows)</h3>
<div class="getrow"><p>returns the GridRow that contains the rowEntity</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rowEntity – {object} – </code>
<p>the gridOptions.data array element instance</p></li>
<li><code ng:non-bindable="">rows – {array} – </code>
<p>[optional] the rows to look in - if not provided then
looks in grid.rows</p></li>
</ul>
</div>
</li>
<li><h3 id="handleWindowResize">handleWindowResize()</h3>
<div class="handlewindowresize"><p>Triggered when the browser window resizes; automatically resizes the grid</p></div>
</li>
<li><h3 id="hasLeftContainer">hasLeftContainer()</h3>
<div class="hasleftcontainer"><p>returns true if rightContainer exists</p></div>
</li>
<li><h3 id="hasLeftContainer">hasLeftContainer()</h3>
<div class="hasleftcontainer"><p>returns true if leftContainer exists</p></div>
</li>
<li><h3 id="hasLeftContainerColumns">hasLeftContainerColumns()</h3>
<div class="hasleftcontainercolumns"><p>returns true if leftContainer has columns</p></div>
</li>
<li><h3 id="hasRightContainerColumns">hasRightContainerColumns()</h3>
<div class="hasrightcontainercolumns"><p>returns true if rightContainer has columns</p></div>
</li>
<li><h3 id="isRTL">isRTL()</h3>
<div class="isrtl"><p>Returns true if grid is RightToLeft</p></div>
</li>
<li><h3 id="modifyRows">modifyRows()</h3>
<div class="modifyrows"><p>creates or removes GridRow objects from the newRawData array.  Calls each registered
rowBuilder to further process the row</p>

<p>This method aims to achieve three things:
1. the resulting rows array is in the same order as the newRawData, we'll call
rowsProcessors immediately after to sort the data anyway
2. if we have row hashing available, we try to use the rowHash to find the row
3. no memory leaks - rows that are no longer in newRawData need to be garbage collected</p>

<p>The basic logic flow makes use of the newRawData, oldRows and oldHash, and creates
the newRows and newHash</p>

<p>```
newRawData.forEach newEntity
  if (hashing enabled)
    check oldHash for newEntity
  else
    look for old row directly in oldRows
  if !oldRowFound     // must be a new row
    create newRow
  append to the newRows and add to newHash
  run the processors</p>

<p>Rows are identified using the hashKey if configured.  If not configured, then rows
are identified using the gridOptions.rowEquality function</p></div>
</li>
<li><h3 id="notifyDataChange">notifyDataChange(type)</h3>
<div class="notifydatachange"><p>Notifies us that a data change has occurred, used in the public
api for users to tell us when they've changed data or some other event that 
our watches cannot pick up</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">type – {string} – </code>
<p>the type of event that occurred - one of the 
uiGridConstants.dataChange values (ALL, ROW, EDIT, COLUMN)</p></li>
</ul>
</div>
</li>
<li><h3 id="preCompileCellTemplates">preCompileCellTemplates()</h3>
<div class="precompilecelltemplates"><p>precompiles all cell templates</p></div>
</li>
<li><h3 id="processRowBuilders">processRowBuilders(gridRow)</h3>
<div class="processrowbuilders"><p>processes all RowBuilders for the gridRow</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">gridRow – {GridRow} – </code>
<p>reference to gridRow</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{GridRow}</code>
– <p>the gridRow with all additional behavior added</p></div>
</div>
</li>
<li><h3 id="processRowsCallback">processRowsCallback(name)</h3>
<div class="processrowscallback"><p>calls the row processors, specifically
intended to reset the sorting when an edit is called,
registered as a dataChangeCallback on uiGridConstants.dataChange.EDIT</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">name – {string} – </code>
<p>column name</p></li>
</ul>
</div>
</li>
<li><h3 id="queueGridRefresh">queueGridRefresh()</h3>
<div class="queuegridrefresh"><p>queues a grid refresh, a way of debouncing all the refreshes we might otherwise issue</p></div>
</li>
<li><h3 id="queueRefresh">queueRefresh()</h3>
<div class="queuerefresh"><p>queues a grid refreshCanvas, a way of debouncing all the refreshes we might otherwise issue</p></div>
</li>
<li><h3 id="redrawCanvas">redrawCanvas([rowsAdded])</h3>
<div class="redrawcanvas"><p>Redraw the rows and columns based on our current scroll position</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">[rowsAdded] – {boolean} – </code>
<p>Optional to indicate rows are added and the scroll percentage must be recalculated</p></li>
</ul>
</div>
</li>
<li><h3 id="refresh">refresh()</h3>
<div class="refresh"><p>Refresh the rendered grid on screen.</p></div>
</li>
<li><h3 id="refreshCanvas">refreshCanvas()</h3>
<div class="refreshcanvas"><p>Builds all styles and recalculates much of the grid sizing</p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>promise that is resolved when the canvas
has been refreshed</p></div>
</div>
</li>
<li><h3 id="refreshRows">refreshRows()</h3>
<div class="refreshrows"><p>Refresh the rendered rows on screen?  Note: not functional at present </p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>promise that is resolved when render completes?</p></div>
</div>
</li>
<li><h3 id="registerColumnBuilder">registerColumnBuilder(columnBuilder)</h3>
<div class="registercolumnbuilder"><p>When the build creates columns from column definitions, the columnbuilders will be called to add
additional properties to the column.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">columnBuilder – {function(colDef, col, gridOptions)} – </code>
<p>function to be called</p></li>
</ul>
</div>
</li>
<li><h3 id="registerColumnsProcessor">registerColumnsProcessor(columnProcessor)</h3>
<div class="registercolumnsprocessor"><p>Register a "columns processor" function. When the columns are updated,
the grid calls each registered "columns processor", which has a chance
to alter the set of columns, as long as the count is not modified.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">columnProcessor – {function(renderedColumnsToProcess, rows)} – </code>
<p>column processor function, which
is run in the context of the grid (i.e. this for the function will be the grid), and
which must return an updated renderedColumnsToProcess which can be passed to the next processor 
in the chain</p></li>
</ul>
</div>
</li>
<li><h3 id="registerDataChangeCallback">registerDataChangeCallback(callback, types)</h3>
<div class="registerdatachangecallback"><p>When a data change occurs, the data change callbacks of the specified type
will be called.  The rules are:</p>

<ul>
<li>when the data watch fires, that is considered a ROW change (the data watch only notices
added or removed rows)</li>
<li>when the api is called to inform us of a change, the declared type of that change is used</li>
<li>when a cell edit completes, the EDIT callbacks are triggered</li>
<li>when the columnDef watch fires, the COLUMN callbacks are triggered</li>
<li>when the options watch fires, the OPTIONS callbacks are triggered</li>
</ul>

<p>For a given event:
- ALL calls ROW, EDIT, COLUMN, OPTIONS and ALL callbacks
- ROW calls ROW and ALL callbacks
- EDIT calls EDIT and ALL callbacks
- COLUMN calls COLUMN and ALL callbacks
- OPTIONS calls OPTIONS and ALL callbacks</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">callback – {function(grid)} – </code>
<p>function to be called</p></li>
<li><code ng:non-bindable="">types – {array} – </code>
<p>the types of data change you want to be informed of.  Values from 
the uiGridConstants.dataChange values ( ALL, EDIT, ROW, COLUMN, OPTIONS ).  Optional and defaults to
ALL </p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{function}</code>
– <p>deregister function - a function that can be called to deregister this callback</p></div>
</div>
</li>
<li><h3 id="registerRowBuilder">registerRowBuilder(rowBuilder)</h3>
<div class="registerrowbuilder"><p>When the build creates rows from gridOptions.data, the rowBuilders will be called to add
additional properties to the row.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rowBuilder – {function(row, gridOptions)} – </code>
<p>function to be called</p></li>
</ul>
</div>
</li>
<li><h3 id="registerRowsProcessor">registerRowsProcessor(processorFunction, priority)</h3>
<div class="registerrowsprocessor"><p>Register a "rows processor" function. When the rows are updated,
the grid calls each registered "rows processor", which has a chance
to alter the set of rows (sorting, etc) as long as the count is not
modified.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">processorFunction – {function(renderedRowsToProcess, columns )} – </code>
<p>rows processor function, which 
is run in the context of the grid (i.e. this for the function will be the grid), and must
return the updated rows list, which is passed to the next processor in the chain</p></li>
<li><code ng:non-bindable="">priority – {number} – </code>
<p>the priority of this processor.  In general we try to do them in 100s to leave room
for other people to inject rows processors at intermediate priorities.  Lower priority rowsProcessors run earlier.</p>

<p>At present all rows visible is running at 50, filter is running at 100, sort is at 200, grouping at 400, selectable rows at 500, pagination at 900 (pagination will generally want to be last)</p></li>
</ul>
</div>
</li>
<li><h3 id="registerStyleComputation">registerStyleComputation(styleComputation)</h3>
<div class="registerstylecomputation"><p>registered a styleComputation function</p>

<p>If the function returns a value it will be appended into the grid's <code>&lt;style&gt;</code> block</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">styleComputation – {function($scope)} – </code>
<p>function</p></li>
</ul>
</div>
</li>
<li><h3 id="removeRowsProcessor">removeRowsProcessor(rows)</h3>
<div class="removerowsprocessor"><p>Remove a registered rows processor</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rows – {function(renderableRows)} – </code>
<p>processor function</p></li>
</ul>
</div>
</li>
<li><h3 id="resetColumnSorting">resetColumnSorting([excludedColumn])</h3>
<div class="resetcolumnsorting"><p>Return the columns that the grid is currently being sorted by</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">[excludedColumn] – {GridColumn} – </code>
<p>Optional GridColumn to exclude from having its sorting reset</p></li>
</ul>
</div>
</li>
<li><h3 id="scrollTo">scrollTo(rowEntity, colDef)</h3>
<div class="scrollto"><p>Scroll the grid such that the specified
row and column is in view</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rowEntity – {object} – </code>
<p>gridOptions.data[] array instance to make visible</p></li>
<li><code ng:non-bindable="">colDef – {object} – </code>
<p>to make visible</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>a promise that is resolved after any scrolling is finished</p></div>
</div>
</li>
<li><h3 id="scrollToIfNecessary">scrollToIfNecessary(gridRow, gridCol)</h3>
<div class="scrolltoifnecessary"><p>Scrolls the grid to make a certain row and column combo visible,
in the case that it is not completely visible on the screen already.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">gridRow – {GridRow} – </code>
<p>row to make visible</p></li>
<li><code ng:non-bindable="">gridCol – {GridCol} – </code>
<p>column to make visible</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>a promise that is resolved when scrolling is complete</p></div>
</div>
</li>
<li><h3 id="sortColumn">sortColumn(column, [direction], [add])</h3>
<div class="sortcolumn"><p>Set the sorting on a given column, optionally resetting any existing sorting on the Grid.
Emits the sortChanged event whenever the sort criteria are changed.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">column – {GridColumn} – </code>
<p>Column to set the sorting on</p></li>
<li><code ng:non-bindable="">[direction] – {uiGridConstants.ASC|uiGridConstants.DESC} – </code>
<p>Direction to sort by, either descending or ascending.
If not provided, the column will iterate through the sort directions: ascending, descending, unsorted.</p></li>
<li><code ng:non-bindable="">[add] – {boolean} – </code>
<p>Add this column to the sorting. If not provided or set to <code>false</code>, the Grid will reset any existing sorting and sort
by this column only</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{Promise}</code>
– <p>A resolved promise that supplies the column.</p></div>
</div>
</li>
<li><h3 id="updateCanvasHeight">updateCanvasHeight()</h3>
<div class="updatecanvasheight"><p>flags all render containers to update their canvas height</p></div>
</li>
</ul>
</div>
<div class="member property"><h2 id="Properties">Properties</h2>
<ul class="properties"><li><h3 id="appScope">appScope</h3>
<div class="appscope"><p>reference to the application scope (the parent scope of the ui-grid element).  Assigned in ui-grid controller
<br/>
use gridOptions.appScopeProvider to override the default assignment of $scope.$parent with any reference</p></div>
</li>
<li><h3 id="columnFooterHeight">columnFooterHeight</h3>
<div class="columnfooterheight"><p>returns the total column footer height</p></div>
</li>
<li><h3 id="footerHeight">footerHeight</h3>
<div class="footerheight"><p>returns the total footer height gridFooter + columnFooter</p></div>
</li>
<li><h3 id="isScrollingHorizontally">isScrollingHorizontally</h3>
<div class="isscrollinghorizontally"><p>set to true when Grid is scrolling horizontally. Set to false via debounced method</p></div>
</li>
<li><h3 id="isScrollingVertically">isScrollingVertically</h3>
<div class="isscrollingvertically"><p>set to true when Grid is scrolling vertically. Set to false via debounced method</p></div>
</li>
<li><h3 id="scrollDirection">scrollDirection</h3>
<div class="scrolldirection"><p>set one of the uiGridConstants.scrollDirection values (UP, DOWN, LEFT, RIGHT, NONE), which tells
us which direction we are scrolling. Set to NONE via debounced method</p></div>
</li>
</ul>
</div>
</div>
