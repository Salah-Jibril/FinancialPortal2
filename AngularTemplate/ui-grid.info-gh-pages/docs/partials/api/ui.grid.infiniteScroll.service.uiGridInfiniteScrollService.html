<h1><code ng:non-bindable="">uiGridInfiniteScrollService</code>
<span class="hint">(service in module <code ng:non-bindable="">ui.grid.infiniteScroll</code>
)</span>
</h1>
<div><h2 id="Description">Description</h2>
<div class="description"><p>Service for infinite scroll features</p></div>
<div class="member method"><h2 id="Methods">Methods</h2>
<ul class="methods"><li><h3 id="adjustInfiniteScrollPosition">adjustInfiniteScrollPosition(grid, percentage)</h3>
<div class="adjustinfinitescrollposition"><p>This function fires 'needLoadMoreData' or 'needLoadMoreDataTop' event based on scrollDirection</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid we're working on</p></li>
<li><code ng:non-bindable="">percentage – {number} – </code>
<p>the percentage through the grid that we want to scroll to</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>a promise that is resolved when the scrolling finishes</p></div>
</div>
</li>
<li><h3 id="adjustScroll">adjustScroll(grid)</h3>
<div class="adjustscroll"><p>Once we are informed that data has been loaded, adjust the scroll position to account for that
addition and to make things look clean.  </p>

<p>If we're scrolling up we scroll to the first row of the old data set - 
so we're assuming that you would have gotten to the top of the grid (from the 20% need more data trigger) by
the time the data comes back.  If we're scrolling down we scoll to the last row of the old data set - so we're
assuming that you would have gotten to the bottom of the grid (from the 80% need more data trigger) by the time
the data comes back.  </p>

<p>Neither of these are good assumptions, but making this a smoother experience really requires
that trigger to not be a percentage, and to be much closer to the end of the data (say, 5 rows off the end).  Even then
it'd be better still to actually run into the end.  But if the data takes a while to come back, they may have scrolled
somewhere else in the mean-time, in which case they'll get a jump back to the new data.  Anyway, this will do for
now, until someone wants to do better.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid we're working on</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>a promise that is resolved when scrolling has finished</p></div>
</div>
</li>
<li><h3 id="handleScroll">handleScroll(args)</h3>
<div class="handlescroll"><p>Called whenever the grid scrolls, determines whether the scroll should
trigger an infinite scroll request for more data</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">args – {object} – </code>
<p>the args from the event</p></li>
</ul>
</div>
</li>
<li><h3 id="initializeGrid">initializeGrid()</h3>
<div class="initializegrid"><p>This method register events and methods into grid public API</p></div>
</li>
<li><h3 id="loadData">loadData(grid)</h3>
<div class="loaddata"><p>This function fires 'needLoadMoreData' or 'needLoadMoreDataTop' event based on scrollDirection
and whether there are more pages upwards or downwards.  It also stores the number of rows that we had previously,
and clears out any saved scroll position so that we know whether or not the user calls <code>saveScrollPercentage</code></p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid we're working on</p></li>
</ul>
</div>
</li>
<li><h3 id="setScrollDirections">setScrollDirections(scrollUp, scrollDown)</h3>
<div class="setscrolldirections"><p>Sets the scrollUp and scrollDown flags, handling nulls and undefined,
and also sets the grid.suppressParentScroll</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">scrollUp – {boolean} – </code>
<p>whether there are pages available up - defaults to false</p></li>
<li><code ng:non-bindable="">scrollDown – {boolean} – </code>
<p>whether there are pages available down - defaults to true</p></li>
</ul>
</div>
</li>
<li><h3 id="setScrollDirections">setScrollDirections(grid, scrollUp, scrollDown)</h3>
<div class="setscrolldirections"><p>Sets the scrollUp and scrollDown flags, handling nulls and undefined,
and also sets the grid.suppressParentScroll</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {grid} – </code>
<p>the grid we're operating on</p></li>
<li><code ng:non-bindable="">scrollUp – {boolean} – </code>
<p>whether there are pages available up - defaults to false</p></li>
<li><code ng:non-bindable="">scrollDown – {boolean} – </code>
<p>whether there are pages available down - defaults to true</p></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
